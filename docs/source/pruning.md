# Pruning

This folder contains ready to use scripts and files that you can leverage to easily use ProgSynth!

<!-- toc -->

- [Type Constraints](#type-constraints)
  - [Pattern](#pattern)
  - [Syntax](#syntax)
- [Sketch](#sketch)

<!-- tocstop -->

## Type Constraints

Since we are using type constraints to produce the grammar, constraints and information can be encoded into types.
However doing so can be tedious, long and prone to errors when done manually.
This is why we made the tools presented below to help you leverage the types.

### Pattern

You will give a set of constraints on patterns, they specify particular structure of your program solutions but not the general structure.
For example you can use this to tell that the left child of a + must not be a + but you cannot tell it that the root primitive should be either a + or -.
That means that constraints defined here apply everywhere and to all levels.
The syntax is explained [here](#syntax).

## Syntax

We will explain the syntax through an example, let us take the calculator DSL (basic arithmetic and constants 0 up to 5).
Here are some constraints:

- ``+ ^+ _``:
     The first ``+`` tell us that we start from a ``+``, then the first argument starts with ``^`` which stands for "anything but the following" followed by a ``+`` so anything but ``+``.
     Then the ``_`` means anything goes so it imposes no constraint.
     This is a *pattern* *constraint* because we would like this constraint to be enforced everywhere.
- ``x 2,3,4,5 _``:
        Here we are working on ``x`` (multiplication), the first argument is ``2,3,4,5`` which is simply a list of primitives which means the first argument of ``x`` can be anything in the given list that is ``2,3,4,5``. The second argument is the same as previously and again this is a *pattern* *constraint*.
- ``+ $(var0) (- _ $(var1))``:
    This one is a bit more complicated.
    First we are working on ``+``, then the first argument is ``$(var0)`` which means it must be a program that can only depend on variable ``var0`` and not on any other variables.
    It is not necessary that ``var0`` be of the matching type (here INT).
    Then the second argument is another expression so we must process it first before coming back to ``+``.
    In this second expression we work on ``-`` whose first argument can be anything and its second argument can only depend on ``var1``.
    Now, that means that the second argument of ``+`` here must be a ``-`` with the desired structure.
    Here is seems quite clear that the resulting constraints depend on the type request and this looks like much more of a *program* *structure* than a *pattern* since it seems relevant enough to do additions with ``var1`` for example.
    Thus the constraint will only model the structure of solutions, that is a valid program in this grammar could be:
    ``(+ (+ var0 1) (- 1 3))``. First, note that the first argument contains a ``+`` which does not have the constraints of the root ``+``. Second, note that the second argument does not depend on ``var1``, the most we can do is forbid a dependence on variables no enforce a dependence on one.

Sometimes it is not possible to express all constraints for a primitive in a signle cosntraint, in that case you can actually use two constraints.
The result will be semantically equivalent.

## Sketch

Sketches are a very powerful way to guide the generation towards what you need since you provide a sketch of the solution.

The syntax is the same as for type constraints, see [syntax](#syntax), the difference is that this is interpreted as a sketch and not a type constraint.
For example:

- ``+ ^+ _``:
    implies that the solutions generated by ProgSynth will all have this pattern, that is they will start with a ``+`` then the first argument is anything but a ``+`` and the second argument can be anything.
    Contrary to type constraints it does not imply that every ``+`` must not have a ``+`` as a first argument, only the one from the root.
- ``* $(var0) (+ 2 _)``:
    implies that the solution will start with a ``*``, then its first argument can depend at most only on ``var0`` and no other variables, its second argument is ``(+ 2 _)`` where ``_`` can be anything.
