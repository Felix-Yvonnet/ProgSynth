# Pruning

This submodule enables the pruning of the grammars generated by ProgSynth reducing drastically their size.
Since ProgSynth tries to enumerate all programs from a grammar reducing its size, pruning removes non relevant programs increasing the chance of finding quickly a solution to your task.
There are currently three ways to do pruning and a script for the PBE specification which tries to find automatically empiricallly such constaints and encode them.

<!-- toc -->

- [Forbidden Patterns](#forbidden-patterns)
- [Local Type Constraints](#local-type-constraints)
  - [Pattern](#pattern)
  - [Syntax](#syntax)
- [Sketch](#sketch)
- [Automatic Discovery](#automatic-discovery)

<!-- tocstop -->

## Forbidden Patterns

The first way to add constraints is when a DSL is instantiated. The second argument given is ``forbidden_patterns: Dict[Tuple[str, int], Str[str]]``.
A key is a tuple ``(name_of_parent_primitive, arg_no)`` and gives access to the set of all primitives that cannot be directly derived for this specific argument of the ``parent_primitive``.
For example:

```python
forbidden = { 
    ("+", 1) : {"+"}, 
    ("-", 0): {"-", "+"}
}
```

We forbid the second argument of ``+`` from being ``+`` and the first argument of ``-`` from being ``-`` or ``+``.

This mechanism is quite powerful but does not enable to encode all constraints however it has the advantage of having no drawbacks.

## Local Type Constraints

Since we are using type constraints to produce the grammar, constraints and information can be encoded into types.
However doing so can be tedious, long and prone to errors when done manually.
This is why we made the tools presented below to help you leverage type constaints.
This is a very powerful tool to add constraints, however it comes at a small cost if you are using neural networks, it is possible that it may increase the size of the grammar prediction layers depending on the abstractions that you use.
One of the advantages of type constraints is that it is a generic way to express constraitns for any typed grammar and ProgSynth only works with typed grammars.
Here is a small example:

```python
from synth.pruning import produce_new_syntax_for_constraints

old_dsl = DSL(syntax, forbidden_patterns)

# my_constraints is a list of string
# type_request is mandatory only if you have variable constraints otheriwse it can be anythign and will be returned as is
# forbidden_patterns enables to avoid redundancies
# progress displays a tqdm progress bar

new_syntax, new_type_request = produce_new_syntax_for_constraints(syntax, my_constraints, type_request, forbidden_patterns, progress=False)

pruned_dsl = DSL(new_syntax, forbidden_patterns)
```

### Pattern

You will give a set of constraints on patterns, they specify particular structure of your program solutions but not the general structure.
For example you can use this to tell that the left child of a ``+`` must not be a ``+`` but you cannot tell it that the root primitive should be either a ``+`` or ``-``, this can be done with a [sketch](#sketch).
That means that constraints defined here apply everywhere and to all depth levels.

## Syntax

We will explain the syntax through an example, let us take the calculator DSL (basic arithmetic and constants 0 up to 5).
Here are some constraints:

- ``+ ^+ _``:
     The first ``+`` tell us that we start from a ``+``, then the first argument starts with ``^`` which stands for "anything but the following" followed by a ``+`` so anything but ``+``.
     Then the ``_`` means anything goes so it imposes no constraint.
     This is a *pattern* *constraint* because we would like this constraint to be enforced everywhere.
- ``x 2,3,4,5 _``:
        Here we are working on ``x`` (multiplication), the first argument is ``2,3,4,5`` which is simply a list of primitives which means the first argument of ``x`` can be anything in the given list that is ``2,3,4,5``. The second argument is the same as previously and again this is a *pattern* *constraint*.
- ``+ $(var0) (- _ $(var1))``:
    This one is a bit more complicated.
    First we are working on ``+``, then the first argument is ``$(var0)`` which means it must be a program that can only depend on variable ``var0`` and not on any other variables.
    It is not necessary that ``var0`` be of the matching type (here INT).
    Then the second argument is another expression so we must process it first before coming back to ``+``.
    In this second expression we work on ``-`` whose first argument can be anything and its second argument can only depend on ``var1``.
    Now, that means that the second argument of ``+`` here must be a ``-`` with the desired structure.
    Here is seems quite clear that the resulting constraints depend on the type request and this looks like much more of a *program* *structure* than a *pattern* since it seems relevant enough to do additions with ``var1`` for example.
    Thus the constraint will only model the structure of solutions, that is a valid program in this grammar could be:
    ``(+ (+ var0 1) (- 1 3))``. First, note that the first argument contains a ``+`` which does not have the constraints of the root ``+``. Second, note that the second argument does not depend on ``var1``, the most we can do is forbid a dependence on variables no enforce a dependence on one.

Sometimes it is not possible to express all constraints for a primitive in a single constraint, in that case you can actually use two constraints.
The result will be semantically equivalent.

## Sketch

Sketches are a very powerful way to guide the generation towards what you need since you provide a sketch of the solution.
Giving a sketch of the solution is probably one if not the method that purnes most programs. 
In our framework, the sketch is encoded into type constraints.
Here is a small example:

```python
from synth.pruning import produce_new_syntax_for_sketch

old_dsl = DSL(syntax, forbidden_patterns)

# my_sketch is a string
# type_request is mandatory here
# forbidden_patterns enables to avoid redundancies

new_syntax, new_type_request = produce_new_syntax_for_sketch(syntax, my_sketch, type_request, forbidden_patterns)

pruned_dsl = DSL(new_syntax, forbidden_patterns)
```

The syntax is the same as for local type constraints, see [syntax](#syntax), the difference is that this is interpreted as a sketch and not a type constraint.
For example:

- ``+ ^+ _``:
    implies that the solutions generated by ProgSynth will all have this pattern, that is they will start with a ``+`` then the first argument is anything but a ``+`` and the second argument can be anything.
    Contrary to type constraints it does not imply that every ``+`` must not have a ``+`` as a first argument, only the one from the root.
- ``* $(var0) (+ 2 _)``:
    implies that the solution will start with a ``*``, then its first argument can depend at most only on ``var0`` and no other variables, its second argument is ``(+ 2 _)`` where ``_`` can be anything.

## Automatic Discovery

The process of finding and enumerating all possible constraints for a DSL is tedious and prone to errors.
ProgSynth provides for some specifications such as PBE a script ``dsl_analyser.py`` which tries to empirically find semantically equivalent programs then produces as many constraints as possible to remove as many as possible semantically equivalent programs.

The script works by either reproducing the distriution from a given dataset or just taking inputs from a given dataset, this enables it to produce inputs to test programs.
It then evaluates programs up to depth 2 of the grammar and builds sets of semantically equivalent programs with respect to this set of inputs.
Some of these programs can then be forbidden using different types of constraints either local type constraints or forbidden patterns.
The script produces two files:
- a python file containing the local type constraints and the forbidden patterns it produced;
- a JSON file containing all semantically equivalent classes of programs et depth 2.
