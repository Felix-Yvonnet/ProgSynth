from typing import Any, Dict, List, Set
from examples.pbe.regexp.type_regex import regex_match, Raw
from synth.syntax.program import Function, Primitive, Program, Variable
from synth.semantic.evaluator import Evaluator


generalized_to_re = {
    "U": "[A-Z]",
    "L": "[a-z]",
    "N": "[0-9]",
    "O": "[^A-Za-z0-9]",
    "W": "\s",
    "begin": "",
    ".": ".",
}


def get_regexp(reg, groups: bool = True):
    modified = ""
    for char in reg:
        if char in generalized_to_re:
            modified += (
                "(" + generalized_to_re[char] + ")"
                if groups
                else generalized_to_re[char]
            )
        else:
            modified = modified[:-1] + char + ")" if groups else modified[:-1] + char
    return modified


def __geometrical__(num_instances: int, probability: float) -> float:
    return ((1 - probability) ** (num_instances - 1)) * probability


def __uniform__(lexicon: List[str]) -> float:
    return 1 / len(lexicon)


def __tuplify__(element: Any) -> Any:
    if isinstance(element, List):
        return tuple(__tuplify__(x) for x in element)
    else:
        return element


class RegexpEvaluator(Evaluator):
    def __init__(self, semantics: Dict[str, Any], use_cache: bool = True) -> None:
        super().__init__()
        self.semantics = semantics
        self.use_cache = use_cache
        self._cache: Dict[Any, Dict[str, Any]] = {}
        self.skip_exceptions: Set[Exception] = set()
        # Statistics
        self._total_requests = 0
        self._cache_hits = 0

        ### duplicated code with task_generator_regexp, to be factorized
        str_lexicon = list([chr(i) for i in range(32, 126)])
        n_lexicon = [chr(i) for i in range(48, 58)]
        u_lexicon = [chr(i) for i in range(65, 91)]
        l_lexicon = [chr(i) for i in range(97, 123)]
        o_lexicon = str_lexicon[1:]  # without whitespace
        o_lexicon = list(set(o_lexicon) - set(n_lexicon + u_lexicon + l_lexicon))

        self.lexicons: Dict[str, List[str]] = {
            "W": ["\s"],
            "N": n_lexicon,
            "U": u_lexicon,
            "L": l_lexicon,
            "O": o_lexicon,
        }

    def eval(self, regexp: str, input: List) -> float:
        """
        key = __tuplify__(regexp)
        if key not in self._cache and self.use_cache:
            self._cache[key] = {}
        evaluations: Dict[str, float] = self._cache[key] if self.use_cache else {}
        if regexp in evaluations:
            return evaluations[regexp]
        """
        try:
            result = 1
            repeated = None
            re = get_regexp(regexp)
            match = regex_match(Raw(re), "".join(input))
            if match is None or match.group() != "".join(input):
                print(
                    "Regexp did not perfectly match with input. This word cannot be generated by this regexp."
                )
                return 0
            group_index = len(match.groups())
            for r in regexp[::-1]:
                self._total_requests += 1
                if r in self.lexicons.keys():
                    if repeated:
                        group = match.groups(group_index)
                        if repeated == "?":
                            result *= __uniform__(self.lexicons) * 0.5
                        else:
                            tmp = 0
                            if repeated == "+":
                                tmp += __uniform__(self.lexicons)
                            tmp *= __geometrical__(
                                len(group), __uniform__(self.lexicons[r])
                            )
                            result *= tmp
                        repeated = None
                    else:
                        result *= __uniform__(self.lexicons[r])
                    group_index -= 1
                elif r in ["+", "?", "*"]:
                    repeated = r
        except Exception as e:
            if type(e) in self.skip_exceptions:
                return 0
            else:
                raise e

        return result

    def clear_cache(self) -> None:
        self._cache.clear()

    @property
    def cache_hit_rate(self) -> float:
        return self._cache_hits / self._total_requests
